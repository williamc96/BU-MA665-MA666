#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Sep 20 16:20:23 2021

@author: Will Cunningham, Juao-Guilherme Rosa & Ben Snyder
"""

#!/usr/bin/env python3

#Question: How does  increase in  R impact  dynamics of the LIF model? 
#Defend answer with equations, and biology, as we did for C in the IF model.
#Determine how the firing rate of the LIF model varies with input I. Plot the firing rate vs I (the “f-I curve”).
#
#Answer: If current is kept constant, an increase in R causes an increase in firing rate.
#Biologically, resistance is a function of the # of open ion channels (R is indirectly inversely proportional to the # of ion channels open).
#More open channels corresponds to a lower resistance, and allows for a loss of ions (+ charge).
#This combats the membrane potential change generated by injecting current.
#Thus, for a constant injected current a greater resistance creates a higher membrane depolarization and greater firing rate.
#
#The code below shows how the firing frequency for a given current input increases with greater resistance.

#Alternatively we can solve the differential equation:
#v'(t) = (k/C-(v(t)/(R*C)))
#shamelessly using wolfram alpha, we can see the solution of this equation is:
#v(t) = c_1 e^(-t/(C*R)) + I * R      ref:  https://www.wolframalpha.com/input/?i=v%27%28t%29-%28k%2FC-%28v%28t%29%2F%28RC%29%29%29+%3D+0
#solving for v(0) = 0 gives c_1 = -I*R, so the full equation is -I*R* e^(-t/(C R)) + I*R OR
# v(t) = I*R(1-e^(-t/(C*R)))
#further, solving for v(t) = 1 (since that's what we're using as threshold) gives:
#t = R*C(log((IR)/(IR - 1)))  https://www.wolframalpha.com/input/?i=c_1*c_2%281-e%5E%28-t%2F%28c_3*c_2%29%29%29+%3D+1+solve+for+t
# we want the firing rate, which is the reciprical of the amount of time it takes to get a single fire: 
#f(I,R,C) = 1/(RC*log((IR)/(IR - 1)))
#for C,R = 1,1 respectively: https://www.wolframalpha.com/input/?i=y+%3D++1%2F(xlog((x)%2F(x+-+1)))


import numpy as np
import matplotlib.pyplot as plt



def return_spikes(I,C,R):                #Input important parameters, and an option to plot V vs t.
  
    Vth = 1;                     #Define the voltage threshold.
    Vreset = 0;                  #Define the reset voltage.
    dt=0.01                      #Set the timestep (0.01s or 10 ms)
    V = np.zeros([1000,1])       #Initialize V.
    V[0]=0.2;                    #Set the initial condition.
    spikes=0

    for k in range(0,999):       #March forward in time,
        V[k+1] = V[k] + dt*(I/C-(V[k]/(R*C))) #Update the voltage, include resistance into the equation
        if V[k+1] > Vth:         #... and check if the voltage exceeds the threshold.
            V[k+1] = Vreset      #... if so, reset the voltage
            spikes = spikes+1         #number of spikes
            
    return(spikes)               #provides output of spike number for use in graphing

def f_I(capacitance, resistance, color):
    max_current=100              #sets the number of currents to test
    slope=1                      #Sets the step between tested currents
    fires = np.zeros([max_current,1])   #Creates empty array to fill with firing data
    current_range = np.array([slope*k for k in range(0,max_current)])   #Creates empty array to fill with current values to test in neuron model

    for i in range(0,max_current):
        fires[i]= return_spikes(current_range[i],capacitance,resistance)/10 #rate of firing (i.e. spikes per 10ms)

    plt.plot(current_range,fires,color)



#Test a low and high value of both resistance and capacitance
plt.xlim(0,30)
plt.ylim(0,30)
plt.xlabel('Current (I)')
plt.ylabel('Frequency (spike/ms)')
#        plt.title('f-I curve'+ ' (Capacitance = ' + str(capacitance) + ', Resistance = ' + str(resistance) + ')')
plt.title('f-I curve')
plt.grid(True, linewidth=0.5, color='k', linestyle='-')
f_I(1,.2,'b')
f_I(2,.2,'b:')
f_I(1,2,'r')
f_I(2,2,'r:')
plt.legend(['C=1, R=0.2','C=2, R=0.2','C=1, R=2','C=2, R=2'])
plt.show()




